@page "/jobs"

@using Backend.Contracts
@using Backend.Contracts.Features.Jobs
@using Orleans.Streams
@using Frontend.Components
@using Frontend.Features.Jobs.Components
@using Backend.Models.Features.Jobs
@using Frontend.Features.Jobs.Models
@using Frontend.Features.Jobs.Services

@implements Orleans.Streams.IAsyncObserver<JobUpdate>

@inject Orleans.IClusterClient ClusterClient
@inject IJobService JobService
@inject IJSRuntime JsRuntime

<JobEditModalComponent Id="@_editModalId" Job="@_editingJob" OnOkCallback="@OnJobEditComplete" />
<JobsListComponent Jobs="@_jobs" OnJobEdit="@OnJobEdit"/>

<div class="mt-4">
    <button class="btn btn-primary" @onclick="@OnAddJobClick">Add Job</button>
</div>

@code
{
    private readonly List<JobModelView> _jobs = new List<JobModelView>();

    private readonly Dictionary<Guid, int> _jobIndexes = new Dictionary<Guid, int>();
    private readonly string _editModalId = $"modal-{Guid.NewGuid().ToString()}";

    private JobModel? _editingJob;

    private async Task OnAddJobClick()
    {
        var job = new JobModel
        {
            JobId = Guid.NewGuid()
        };

        AddJob(job);

        await JobService.UpdateJob(job);
    }

    protected override async Task OnInitializedAsync()
    {
        var allJobs = await JobService.LoadAllJobs();
        foreach (var job in allJobs)
        {
            var modelView = AddJob(job);
            modelView.Status = JobModelViewStatus.NotActive;
        }

        var sp = ClusterClient.GetStreamProvider(Constants.StreamProviderName);
        var updatesStream = sp.GetStream<JobUpdate>(JobsConstants.JobStreamId, JobsConstants.UpdatesStreamNs);
        await updatesStream.SubscribeAsync(this);

        var musterStream = sp.GetStream<JobMuster>(JobsConstants.JobStreamId, JobsConstants.MusterStreamNs);
        await musterStream.OnNextAsync(JobMuster.Instance);
    }

    private async Task OnJobEdit(JobModelView job)
    {
        _editingJob = job.Model;

        StateHasChanged();

        await JsRuntime.InvokeAsync<object>("showModal", new object[] {$"#{_editModalId}"});
    }

    private async Task OnJobEditComplete()
    {
        await JsRuntime.InvokeAsync<object>("hideModal", new object[] {$"#{_editModalId}"});

        StateHasChanged();

        if (_editingJob != null)
        {
            await JobService.UpdateJob(_editingJob);

            _editingJob = null;
        }
    }

    private JobModelView AddJob(JobModel job)
    {
        var modelView = new JobModelView(job);
        _jobs.Add(modelView);
        _jobIndexes.Add(job.JobId, _jobs.Count - 1);

        return modelView;
    }

    private JobModelView? TryFindJob(Guid id)
    {
        if (_jobIndexes.TryGetValue(id, out var index))
        {
            return _jobs[index];
        }

        return null;
    }

    async Task IAsyncObserver<JobUpdate>.OnNextAsync(JobUpdate item, StreamSequenceToken token)
    {
        if (TryFindJob(item.JobId) is {} existingModel)
        {
    // nothing
        }
        else
        {
            if (await JobService.LoadJob(item.JobId) is {} loadedJob)
            {
                existingModel = AddJob(loadedJob);
            }
            else
            {
                throw new Exception($"Job '{item.JobId.ToString()}' not found");
            }
        }

        switch (item)
        {
            case JobUpdate.Muster _:
            {
                existingModel.Status = JobModelViewStatus.Active;

                break;
            }

            case JobUpdate.Update update:
            {
                existingModel.Status = JobModelViewStatus.Active;

                break;
            }

            case JobUpdate.Delete _:
            {
                existingModel.Status = JobModelViewStatus.Deleted;

                break;
            }
        }
    }

    Task IAsyncObserver<JobUpdate>.OnCompletedAsync()
    {
        throw new NotImplementedException();
    }

    Task IAsyncObserver<JobUpdate>.OnErrorAsync(Exception ex)
    {
        throw new NotImplementedException();
    }
}